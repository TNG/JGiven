{"name":"JGiven","tagline":"BDD for Java in Java","body":"# JGiven\r\n\r\n(c) 2013-2014 under the Apache License\r\n\r\n## Back to the roots\r\n\r\n* Write your scenarios in plain Java and use all your known IDE features without the need for any additional plugin\r\n* No need for additional languages like Groovy or Scala\r\n* No need to work with text files and regular expressions to bind text to code\r\n* No need to write tests mixed with HTML\r\n* No extra test-runner, just use JUnit or TestNG\r\n* Get reports that business owners and domain experts can read and understand\r\n\r\n### Example\r\n\r\n```Java\r\n\r\n@Test\r\npublic void a_pancake_can_be_fried_out_of_an_egg_milk_and_flour() {\r\n    given().an_egg().\r\n        and().some_milk().\r\n        and().the_ingredient( \"flour\" );\r\n\r\n    when().the_cook_mangles_everthing_to_a_dough().\r\n        and().the_cook_fries_the_dough_in_a_pan();\r\n\r\n    then().the_resulting_meal_is_a_pan_cake();\r\n}\r\n```\r\n\r\nThe above test can be executed like any JUnit test.\r\nDuring the execution, JSON files are generated that can then be used afterwards to generated test reports.\r\nBy default, a plain text report is shown in the console, which would look as follows:\r\n\r\n```\r\nScenario: a pancake can be fried out of an egg milk and flour\r\n\r\n  Given an egg\r\n    And some milk\r\n    And the ingredient flour\r\n\r\n   When the cook mangles everything to a dough\r\n    And the cook fries the dough in a pan\r\n\r\n   Then the resulting meal is a pan cake\r\n```\r\n\r\n## Principles\r\n\r\n* Scenarios are written as Java code.\r\n* No annotations are needed, because JGiven directly parses the Java method names and parameters during the test execution.\r\n* Methods should be written in Snake_Case to have the correct case in the reports.\r\n* Scenarios consist of so-called stages, which share state by injection\r\n\r\n## Stages and State Injection\r\n\r\nA JGiven scenario consists of multiple stages. Typically there is a stage for each phase of a scenario: a given stage, a when stage and a then stage,\r\nhowever, it is also possible to just use one stage or use arbitrary many stages.\r\nA stage is implemented by a stage class that contains methods representing the steps that can be used in the scenario.\r\nThe big advantage of this modular concept is that stages can be easily reused by different scenarios.\r\n\r\nStage classes are POJOs that follow the fluent-interface pattern. This means that all methods return the this-reference.\r\nIn order to work together with inheritance, a stage class should have a type parameter SELF that extends the stage class itself.\r\nJGiven also provides the helper class Stage that provides a self() method to return the SELF type parameter.\r\nThis is best understood by an example:\r\n\r\n```\r\npublic class GivenIngredients<SELF extends GivenIngredients> extends Stage<SELF> {\r\n   List<String> ingredients = new ArrayList<String>();\r\n\r\n   public SELF an_egg() {\r\n      ingredients.add(\"Egg\");\r\n      return self();\r\n   }\r\n   ...\r\n}\r\n```\r\n\r\nStages share state by using injection. This works by annotating the fields with a special annotation @ScenarioState.\r\nThe values of these fields are shared between all stages that have the same field.\r\n\r\nFor example, to be able to access the value of the ingredients field of the GivenIngredients stage in the WhenCook stage one has to annotate that field accordingly:\r\n\r\n```\r\npublic class GivenIngredients<SELF extends GivenIngredients> extends Stage<SELF> {\r\n   @ScenarioState\r\n   List<String> ingredients = new ArrayList<String>();\r\n   ...\r\n}\r\n```\r\n\r\n```\r\npublic class WhenCook<SELF extends WhenCook> extends Stage<SELF> {\r\n   @ExpectedScenarioState\r\n   List<String> ingredients = new ArrayList<String>();\r\n\r\n   @ExpectedScenarioState\r\n   String cook;\r\n\r\n   @ProvidedScenarioState\r\n   String meal;\r\n   ...\r\n\r\n   public WhenCook the_cook_mangles_everthing_to_a_dough() {\r\n       meal = cook.makeADough( ingredients );\r\n   }\r\n\r\n}\r\n```\r\n\r\nInstead of the @ScenarioState annotation one can also use @ExpectedScenarioState and @ProvidedScenarioState to indicate whether the state is\r\nexpected by the stage or provided by the stage.\r\n\r\n## Parameters\r\n\r\nMethod parameters are by default added to the end of the sentence as shown in the example above.\r\n\r\n### Parameters within a sentence\r\n\r\nTake the following example:\r\n```\r\nGiven <neggs> eggs\r\n```\r\nThis cannot be written directly as a single method name because parameters can only come at the end of the method.\r\nJGiven solves this problem by using the $ character as follows:\r\n```\r\ngiven().$_eggs(neggs);\r\n```\r\nThis is not perfectly readable at first glance, but as soon as you are used to reading $ as a parameter it comes quite natural.\r\nThe generated report will replace the $ with the corresponding parameter.\r\nSo the generated report will look as follows (given <neggs> was 5):\r\n```\r\nGiven 5 eggs\r\n```\r\n\r\n# License\r\n\r\nJGiven is published under the Apache License 2.0, see\r\nhttp://www.apache.org/licenses/LICENSE-2.0 for details.\r\n\r\n# Installation\r\n\r\n## Maven\r\nAdd the following dependency to your POM file:\r\n\r\n```\r\n<dependency>\r\n   <groupId>com.tngtech.jgiven</groupId>\r\n   <artifactId>jgiven-junit</artifactId>\r\n   <version>0.1.7</version>\r\n   <scope>test</scope>\r\n</dependency>\r\n```\r\n\r\nfor TestNG instead of JUnit use:\r\n```\r\n<dependency>\r\n   <groupId>com.tngtech.jgiven</groupId>\r\n   <artifactId>jgiven-testng</artifactId>\r\n   <version>0.1.7</version>\r\n   <scope>test</scope>\r\n</dependency>\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}